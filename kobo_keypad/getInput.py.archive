import struct, pygame, os, time
from pygame.locals import *
from subprocess import call
import thread
from Queue import Queue

onKobo=False
#import input_test

# Tell SDL that there is no mouse.
os.environ['SDL_NOMOUSE'] = '1'

keys="123456789B0G"
execute=False

tsdevice = "/dev/input/event1"
keydevice = "/dev/input/event0"
format = "iihhi"

pygame.init()
screen = pygame.display.set_mode((800, 600), pygame.FULLSCREEN)

pygame.mouse.set_visible(False)

clock = pygame.time.Clock()
font = pygame.font.Font("Cabin-Regular.otf", 50)


x = 0
y = 0
touching = False
running = True
buff=""

def buffer( ch ):
    global buff, execute
    if (ch=="b"): 
        if(len(buff) > 0):
            buff=buff[:-1]
    elif (ch=="g"):
        execute=True
    else:
        buff += ch


        
def get_touch_input(msgQ):
    """Runs in a loop getting the touch position"""
    
    global x, y, touching, running
    touchscreen = open(tsdevice,"rb")
    
    ts_event = touchscreen.read(16)
    
    while running:
        # The touch screen.
        (ts_time1, ts_time2, ts_type, ts_code, ts_value) = struct.unpack(format,ts_event)
        if ts_type == 3:
            if ts_code == 0:
                x = ts_value
            if ts_code == 1:
                y = ts_value
        if ts_type == 0:
            print x, ":", y
        elif ts_type == 1:
            touching = False
        elif ts_type == 3:
            touching = True
            
        ts_event = touchscreen.read(16)

    
        
def flash_screen():
    screen.fill((0, 0, 0))
    pygame.display.update()
    if (onKobo): call(["./full_updatescreen"])
    time.sleep(0.2)
    screen.fill((255, 255, 255))
    pygame.display.update()
    if (onKobo): call(["./full_updatescreen"])
        
def renderKeypad():
    labels=[]
    rects=[]
    px=0
    py=0
    for i in keys:
        l= font.render(i, 0, (0,0,0))
        lr=l.get_rect()
        lrx = px*150+120
        lry= py*120+120
        
        lr.topleft=(lrx,lry)
        labels.append([i,l,lr, (lrx,lry)])
        rects.append(lr)
        
        px +=1
        if (px>2):
            px=0
            py+=1
        
    print(labels)    
    return(rects, labels)






touchMsgQ = Queue.queue();
thread.start_new_thread(get_touch_input, (touchMsgQ, ))
(rects, labels)= renderKeypad()
touch_rect = pygame.rect.Rect(x, y, 5, 5)

while 1:
    
    screen.fill((255, 255, 255))
    
    touch_rect.center = x, y
    
    which=touch_rect.collidelist(rects)
    if not touching and (which>=0):
        ch  = labels[which][0]
        buffer( ch)
        print ch
        touching=True
        
    if x > 750 and y > 550:
        flash_screen()
        x = 0
        y = 0
        
    pygame.draw.rect(screen, (0, 0, 0), (750, 550, 50, 50), 1)
    for i in range(len(keys)):
        screen.blit(labels[i][1], labels[i][3])
        
    screen.blit(font.render(buff, 0, (0,0,0)), (10,10))
    
        
    
    pygame.display.update()
    
    if (onKobo): call(["./full_monochrome"]) 
    
    clock.tick(10)
